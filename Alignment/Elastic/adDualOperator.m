function [v,dv]=adDualOperator(v,w,sp,G,ups,F,FH)

%ADDUALOPERATOR   Computes the negative dual of the ad operator (ad*), with 
%ad operator being the negative of the Lie bracket (derivative of w along 
%the flow generated by v), following [1] M Hernandez, "PDE-constrained 
%LDDMM via geodesic shooting and inexact Gauss–Newton–Krylov optimization 
%using the incremental adjoint Jacobi equations," Phys Med Biol, 
%64:025002(16p), 2019; [2] MI Miller, A Trouve, L Younes, "Geodesic 
%Shooting for Computational Anatomy," J Math Imaging Vis, 24:209-228 
%(2006); [3] M Zhang, PT Fletcher, "Fast Diffeomorphic Image Registration 
%via Fourier-Approximated Lie Algebras," 127:61-73, 2019. This is 
%(wv')D-(Dv)'w.
%   [V,DV,DW]=ADDUALOPERATOR(V,W,SP,G,UPS)
%   * V is a field in Fourier domain
%   * W is another field in Fourier domain
%   * SP is the spacing of the spatial grid
%   * G are first order centered finite difference filters along different
%   dimensions
%   * UPS is a padding factor for circular convolutions
%   ** V is the result of the application of the operator
%   ** DV is the spatial gradient of the original field V
%

ND=length(sp);
if isscalar(ups);ups=ups*ones(1,ND);end
N=size(v);N=N(1:ND);
if ~any(ups==0)
    M=round(N.*ups);ups=M./N;
    if nargin<6;F=buildMapSpace(v,1,M,N);FH=buildMapSpace(v,0,M,N);end
    dv=deformationGradientTensor(v,sp,G,1);
else
    dv=deformationGradientTensorSpace(v,sp);
end
v=permute(v,[1:ND ND+2 ND+1]);
if ~any(ups==0);v=mapSpace(v,0,F,FH);w=mapSpace(w,0,F,FH);dv=mapSpace(dv,0,F,FH);end
v=bsxfun(@times,w,v);
w=sum(bsxfun(@times,dv,w),ND+1);
if ~any(ups==0)
    v=mapSpace(v,1,F,FH);w=mapSpace(w,1,F,FH);
    v=deformationGradientTensor(v,sp,G,1);
else
    v=deformationGradientTensorSpace(v,sp);
end
w=permute(w,[1:ND ND+2 ND+1]);
v=v+w;
